<script>
window.addEventListener("load", function() {
    console.log("Window loaded, searching for Leaflet map...");
    
    let mapInstance = null;
    
    // Поиск инстанса карты Leaflet
    for (let key in window) {
        if (window[key] && typeof window[key] === 'object' && window[key].hasOwnProperty('_leaflet_id')) {
             if (window[key] instanceof L.Map) {
                mapInstance = window[key];
                break;
             }
        }
    }
    
    if (!mapInstance) { 
        console.error("Leaflet map not found."); 
        return; 
    }

    window.currentRasterLayer = null; 
    let pendingRasterName = null;

    const geojsonCache = new Map();
    const activeLayers = new Map();

    // --- ФУНКЦИЯ: Обновление Легенды ---
    function updateLegend(stats) {
        const legendContainer = document.getElementById('raster-legend-container');
        const legendBar = document.getElementById('legend-bar');
        const legendMin = document.getElementById('legend-min');
        const legendMax = document.getElementById('legend-max');
        const legendUnit = document.getElementById('legend-unit');

        // Если статистики нет или это RGB (ортофото), скрываем легенду
        if (!stats || stats.ramp === 'rgb') {
            legendContainer.style.display = 'none';
            return;
        }

        legendContainer.style.display = 'block';
        
        // Устанавливаем текст
        legendMin.innerText = stats.min;
        legendMax.innerText = stats.max;
        legendUnit.innerText = stats.unit ? `(${stats.unit})` : '';

        // Рисуем градиент из цветов
        if (stats.colors && stats.colors.length > 0) {
            const gradientStr = 'linear-gradient(to right, ' + stats.colors.join(', ') + ')';
            legendBar.style.background = gradientStr;
        }
    }

    // --- РАСТРЫ ---
    async function loadRaster(qualname) {
        pendingRasterName = qualname;

        // Скрываем легенду при начале загрузки
        document.getElementById('raster-legend-container').style.display = 'none';

        if (window.currentRasterLayer) { 
            mapInstance.removeLayer(window.currentRasterLayer); 
            window.currentRasterLayer = null; 
        }

        if (!qualname) return;
        
        const [schema, table] = qualname.split('.', 2);
        const url = `/api/gis/raster?schema=${schema}&table=${table}`;

        try {
            const r = await fetch(url);
            if (!r.ok) throw new Error(await r.text());
            const js = await r.json();
            
            if (pendingRasterName !== qualname) {
                console.log("Игнорируем устаревший слой:", qualname);
                return; 
            }
            
            const opacity = parseFloat(document.getElementById('raster-opacity').value);
            
            const newLayer = L.imageOverlay(js.data_url, js.bounds, {
                opacity: opacity,
                pane: 'overlayPane', 
                interactive: false,
                zIndex: 1
            });

            newLayer.addTo(mapInstance);
            window.currentRasterLayer = newLayer; 
            mapInstance.fitBounds(js.bounds);

            // Обновляем легенду полученной статистикой
            if (js.stats) {
                updateLegend(js.stats);
            }

        } catch(e) { 
            console.error('Raster error:', e); 
        }
    }

    // --- ВЕКТОРЫ (без изменений) ---
    async function toggleVectorLayer(checkbox) {
        const id = checkbox.id;
        
        if (!checkbox.checked) {
            if (activeLayers.has(id)) {
                mapInstance.removeLayer(activeLayers.get(id));
                activeLayers.delete(id);
            }
            return;
        }

        const table = checkbox.dataset.table; 
        const filterCol = checkbox.dataset.col; 
        const filterVal = checkbox.dataset.val; 
        const color = checkbox.dataset.color || '#3388ff';
        const label = checkbox.dataset.label;

        let geojsonData = geojsonCache.get(table);
        if (!geojsonData) {
            try {
                const [schema, tblName] = table.split('.', 2);
                const url = `/api/gis/geojson?schema=${schema}&table=${tblName}`;
                const r = await fetch(url);
                if (!r.ok) throw new Error('Fetch failed');
                geojsonData = await r.json();
                
                if (!geojsonData || !geojsonData.features) geojsonData = {type: "FeatureCollection", features: []};
                
                geojsonCache.set(table, geojsonData);
            } catch (e) {
                console.error("Error loading vector:", table, e);
                return;
            }
        }

        const lyr = L.geoJSON(geojsonData, {
            filter: function(feature) {
                if (filterCol && filterVal) {
                    let prop = feature.properties[filterCol];
                    if (typeof prop === 'string') {
                        prop = prop.trim();
                    }
                    return prop === filterVal;
                }
                return true; 
            },
            style: function(feature) {
                return {
                    color: color,      
                    weight: 1,
                    opacity: 1,
                    fillColor: color,  
                    fillOpacity: 0.7
                };
            },
            pointToLayer: (f, latlng) => L.circleMarker(latlng, { 
                radius: 6, 
                color: '#fff', 
                weight: 1, 
                fillColor: color, 
                fillOpacity: 0.9 
            }),
            onEachFeature: (f, l) => { 
                if (f.properties) {
                    let content = `<div style='font-family:sans-serif; font-size:12px;'><strong>${label}</strong><br>`;
                    for (const [k, v] of Object.entries(f.properties)) {
                        if (v !== null && k !== 'gid' && k !== 'geom') {
                            let displayVal = typeof v === 'string' ? v.trim() : v;
                            content += `<b>${k}:</b> ${displayVal}<br>`;
                        }
                    }
                    content += "</div>";
                    l.bindPopup(content); 
                }
            }
        });

        lyr.addTo(mapInstance);
        activeLayers.set(id, lyr);
    }

    // --- EVENT LISTENERS ---

    const rasterSelect = document.getElementById('raster-select');
    if (rasterSelect) {
        rasterSelect.addEventListener('change', e => loadRaster(e.target.value));
    }

    const opacityInput = document.getElementById('raster-opacity');
    if (opacityInput) {
        opacityInput.addEventListener('input', e => {
            if (window.currentRasterLayer) {
                window.currentRasterLayer.setOpacity(parseFloat(e.target.value));
            }
        });
    }
    
    document.querySelectorAll('.vector-checkbox').forEach(cb => {
        cb.addEventListener('change', () => toggleVectorLayer(cb));
    });
});
</script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
<link rel="stylesheet" href="/static/css/map.css">

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
    // Старая функция
    function switchThing(containerId, thingId) {
        document.querySelectorAll('#' + containerId + ' .thing-metrics').forEach(el => el.style.display = 'none');
        const shown = document.getElementById('metrics-thing-' + thingId);
        if (shown) shown.style.display = 'block';
        document.querySelectorAll('#' + containerId + ' .dash-btn').forEach(el => el.style.display='none');
        const btn = document.getElementById('btn-thing-' + thingId);
        if (btn) btn.style.display='inline-block';
    }

    // Ручное управление аккордеоном
    function toggleGisAccordion(btn, targetId) {
        const el = document.getElementById(targetId);
        if (!el) return;
        if (window.bootstrap && window.bootstrap.Collapse) {
            const bsCollapse = bootstrap.Collapse.getOrCreateInstance(el, {toggle: false});
            bsCollapse.toggle();
        } else {
            if (el.classList.contains('show')) {
                el.classList.remove('show');
            } else {
                el.classList.add('show');
            }
        }
        if (btn.classList.contains('collapsed')) {
            btn.classList.remove('collapsed');
            btn.setAttribute('aria-expanded', 'true');
        } else {
            btn.classList.add('collapsed');
            btn.setAttribute('aria-expanded', 'false');
        }
    }
</script>

<div class="gis-control-wrap">
    <div class="d-flex justify-content-between align-items-center mb-2">
        <h5 class="mb-0">Слои карты</h5>
        <span class="toggle-gis-btn text-primary" style="cursor:pointer;" onclick="document.getElementById('gis-body').style.display = document.getElementById('gis-body').style.display === 'none' ? 'block' : 'none'">
            <i class="bi bi-list"></i>
        </span>
    </div>
    
    <div id="gis-body">
        <div class="mb-3">
            <label class="form-label small fw-bold">Растровый фон</label>
            <select id="raster-select" class="form-select form-select-sm mb-2">
                <option value="">— нет —</option>
                {% for r in raster_layers %}
                <option value="{{ r.schema }}.{{ r.name }}">{{ r.title }}</option>
                {% endfor %}
            </select>
            
            <label for="raster-opacity" class="form-label small text-muted mb-0 d-flex justify-content-between">
                <span>Прозрачность слоя</span>
                <span id="opacity-val">70%</span>
            </label>
            <input type="range" id="raster-opacity" class="form-range" min="0" max="1" step="0.1" value="0.7" 
                   oninput="document.getElementById('opacity-val').innerText = Math.round(this.value * 100) + '%'"/>

            <div id="raster-legend-container" class="mt-3 p-2 bg-light border rounded" style="display: none;">
                <div class="d-flex justify-content-between align-items-center small mb-1">
                    <span id="legend-min" class="fw-bold text-muted">0</span>
                    <span id="legend-unit" class="text-secondary" style="font-size: 0.8em;"></span>
                    <span id="legend-max" class="fw-bold text-muted">100</span>
                </div>
                <div id="legend-bar" style="height: 12px; border-radius: 6px; width: 100%; border: 1px solid #ccc;"></div>
            </div>
        </div>

        <hr class="my-2">

        <label class="form-label small fw-bold mb-2">Векторные данные</label>
        
        <div class="mb-2">
            {% for layer in vector_presentation.layers %}
            <div class="form-check vector-item">
                <input class="form-check-input vector-checkbox" type="checkbox" 
                       id="v-{{ layer.table }}"
                       data-table="{{ layer.table }}"
                       data-color="{{ layer.color }}"
                       data-label="{{ layer.label }}">
                <label class="form-check-label d-flex align-items-center" for="v-{{ layer.table }}">
                    <span class="color-dot me-2" style="background-color: {{ layer.color }}; width: 12px; height: 12px; border-radius: 50%; display: inline-block;"></span>
                    {{ layer.label }}
                </label>
            </div>
            {% endfor %}
        </div>

        <div class="accordion accordion-flush" id="gisUniqueAccordion">
            {% for group in vector_presentation.groups %}
            <div class="accordion-item" style="border: none;">
                <h2 class="accordion-header" id="gis-heading-{{ loop.index }}">
                    <button class="accordion-button collapsed py-2 px-0 shadow-none" 
                            type="button" 
                            onclick="toggleGisAccordion(this, 'gis-group-{{ loop.index }}')"
                            aria-expanded="false">
                        {{ group.name }}
                    </button>
                </h2>
                <div id="gis-group-{{ loop.index }}" class="accordion-collapse collapse">
                    <div class="accordion-body px-0 py-1">
                        {% for item in group.options %}
                        <div class="form-check vector-item">
                            <input class="form-check-input vector-checkbox" type="checkbox" 
                                   id="v-{{ group.table }}-{{ group.column }}-{{ item.val }}"
                                   data-table="{{ group.table }}"
                                   data-col="{{ group.column }}"
                                   data-val="{{ item.val }}"
                                   data-color="{{ item.color }}"
                                   data-label="{{ item.label }}">
                            <label class="form-check-label d-flex align-items-center" for="v-{{ group.table }}-{{ group.column }}-{{ item.val }}">
                                <span class="color-dot me-2" style="background-color: {{ item.color }}; width: 12px; height: 12px; border-radius: 50%; display: inline-block;"></span>
                                {{ item.label }}
                            </label>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
        
    </div>
</div>

<style>
.vector-item {
    font-size: 0.9rem;
    margin-bottom: 0.25rem;
}
.accordion-button {
    font-size: 0.95rem;
    font-weight: 600;
    background-color: transparent !important;
}
.accordion-button:not(.collapsed) {
    color: var(--bs-primary);
    box-shadow: none;
}
.accordion-button::after {
    transform: scale(0.8);
}
</style>