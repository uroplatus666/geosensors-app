<script>
window.addEventListener("load", function() {
    console.log("Window loaded, searching for Leaflet map...");
    
    let mapInstance = null;
    
    // Поиск инстанса карты Leaflet
    for (let key in window) {
        if (window[key] && typeof window[key] === 'object' && window[key].hasOwnProperty('_leaflet_id')) {
             if (window[key] instanceof L.Map) {
                mapInstance = window[key];
                break;
             }
        }
    }
    
    if (!mapInstance) { 
        console.error("Leaflet map not found."); 
        return; 
    }

    // Глобальная переменная для хранения текущего слоя на карте
    window.currentRasterLayer = null; 
    
    // Новая переменная: хранит имя последнего выбранного слоя
    // Это защита от "гонки запросов" (Race Condition)
    let pendingRasterName = null;

    const geojsonCache = new Map();
    const activeLayers = new Map();

    // --- РАСТРЫ ---
    async function loadRaster(qualname) {
        // 1. Запоминаем, какой слой мы ХОТИМ видеть прямо сейчас
        pendingRasterName = qualname;

        // 2. Сразу удаляем старый слой, если он есть на карте
        if (window.currentRasterLayer) { 
            mapInstance.removeLayer(window.currentRasterLayer); 
            window.currentRasterLayer = null; 
        }

        // Если выбрано "— нет —", просто выходим (слой уже удален выше)
        if (!qualname) return;
        
        const [schema, table] = qualname.split('.', 2);
        const url = `/api/gis/raster?schema=${schema}&table=${table}`;

        try {
            const r = await fetch(url);
            if (!r.ok) throw new Error(await r.text());
            const js = await r.json();
            
            // 3. ПРОВЕРКА АКТУАЛЬНОСТИ: 
            // Пока мы качали этот слой, пользователь мог выбрать другой.
            // Если pendingRasterName изменился, значит этот результат уже не нужен.
            if (pendingRasterName !== qualname) {
                console.log("Игнорируем устаревший слой:", qualname);
                return; 
            }
            
            const opacity = parseFloat(document.getElementById('raster-opacity').value);
            
            const newLayer = L.imageOverlay(js.data_url, js.bounds, {
                opacity: opacity,
                pane: 'overlayPane', 
                interactive: false,
                zIndex: 1
            });

            newLayer.addTo(mapInstance);
            window.currentRasterLayer = newLayer; // Сохраняем ссылку на актуальный слой
            mapInstance.fitBounds(js.bounds);
        } catch(e) { 
            console.error('Raster error:', e); 
        }
    }

    // --- ВЕКТОРЫ ---
    async function toggleVectorLayer(checkbox) {
        const id = checkbox.id;
        
        if (!checkbox.checked) {
            if (activeLayers.has(id)) {
                mapInstance.removeLayer(activeLayers.get(id));
                activeLayers.delete(id);
            }
            return;
        }

        const table = checkbox.dataset.table; 
        const filterCol = checkbox.dataset.col; 
        const filterVal = checkbox.dataset.val; 
        const color = checkbox.dataset.color || '#3388ff';
        const label = checkbox.dataset.label;

        let geojsonData = geojsonCache.get(table);
        if (!geojsonData) {
            try {
                const [schema, tblName] = table.split('.', 2);
                const url = `/api/gis/geojson?schema=${schema}&table=${tblName}`;
                const r = await fetch(url);
                if (!r.ok) throw new Error('Fetch failed');
                geojsonData = await r.json();
                
                if (!geojsonData || !geojsonData.features) geojsonData = {type: "FeatureCollection", features: []};
                
                geojsonCache.set(table, geojsonData);
            } catch (e) {
                console.error("Error loading vector:", table, e);
                return;
            }
        }

        const lyr = L.geoJSON(geojsonData, {
            filter: function(feature) {
                if (filterCol && filterVal) {
                    let prop = feature.properties[filterCol];
                    if (typeof prop === 'string') {
                        prop = prop.trim();
                    }
                    return prop === filterVal;
                }
                return true; 
            },
            style: function(feature) {
                return {
                    color: color,      
                    weight: 1,
                    opacity: 1,
                    fillColor: color,  
                    fillOpacity: 0.7
                };
            },
            pointToLayer: (f, latlng) => L.circleMarker(latlng, { 
                radius: 6, 
                color: '#fff', 
                weight: 1, 
                fillColor: color, 
                fillOpacity: 0.9 
            }),
            onEachFeature: (f, l) => { 
                if (f.properties) {
                    let content = `<div style='font-family:sans-serif; font-size:12px;'><strong>${label}</strong><br>`;
                    for (const [k, v] of Object.entries(f.properties)) {
                        if (v !== null && k !== 'gid' && k !== 'geom') {
                            let displayVal = typeof v === 'string' ? v.trim() : v;
                            content += `<b>${k}:</b> ${displayVal}<br>`;
                        }
                    }
                    content += "</div>";
                    l.bindPopup(content); 
                }
            }
        });

        lyr.addTo(mapInstance);
        activeLayers.set(id, lyr);
    }

    // --- EVENT LISTENERS ---

    const rasterSelect = document.getElementById('raster-select');
    if (rasterSelect) {
        rasterSelect.addEventListener('change', e => loadRaster(e.target.value));
    }

    const opacityInput = document.getElementById('raster-opacity');
    if (opacityInput) {
        opacityInput.addEventListener('input', e => {
            if (window.currentRasterLayer) {
                window.currentRasterLayer.setOpacity(parseFloat(e.target.value));
            }
        });
    }
    
    document.querySelectorAll('.vector-checkbox').forEach(cb => {
        cb.addEventListener('change', () => toggleVectorLayer(cb));
    });
});
</script>